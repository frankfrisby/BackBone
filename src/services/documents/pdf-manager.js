/**
 * PDF Manager - Generate PDF documents for BACKBONE deliverables
 * Uses PDFKit to create professional reports, research papers, and briefs.
 */
import PDFDocument from "pdfkit";
import fs from "fs";
import path from "path";
import { getDataDir } from "../paths.js";

const DOCS_DIR = path.join(getDataDir(), "documents");

function ensureDir(dir) {
  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
}

function resolveDocPath(name) {
  ensureDir(DOCS_DIR);
  if (!name.endsWith(".pdf")) name += ".pdf";
  return path.join(DOCS_DIR, name);
}

/**
 * Create a professional PDF report.
 * @param {string} filename - Output filename
 * @param {Object} options
 * @param {string} options.title - Report title
 * @param {string} [options.subtitle] - Subtitle/date line
 * @param {string} [options.author] - Author name
 * @param {Array<{heading?:string, body?:string, bullets?:string[], table?:{headers:string[], rows:string[][]}}>} options.sections
 * @returns {Promise<{path:string, pages:number}>}
 */
export async function createReport(filename, { title, subtitle, author = "BACKBONE Engine", sections = [] } = {}) {
  const filePath = resolveDocPath(filename);

  return new Promise((resolve, reject) => {
    const doc = new PDFDocument({
      size: "LETTER",
      margins: { top: 60, bottom: 60, left: 60, right: 60 },
      bufferPages: true,
      info: { Title: title, Author: author }
    });

    const stream = fs.createWriteStream(filePath);
    doc.pipe(stream);

    // Title page
    doc.fontSize(28).font("Helvetica-Bold").fillColor("#1a1a2e")
       .text(title, { align: "center" });

    if (subtitle) {
      doc.moveDown(0.5).fontSize(14).font("Helvetica").fillColor("#555555")
         .text(subtitle, { align: "center" });
    }

    doc.moveDown(0.3).fontSize(10).fillColor("#888888")
       .text(`Generated by ${author} | ${new Date().toLocaleDateString()}`, { align: "center" });

    doc.moveDown(1.5);

    // Horizontal rule
    doc.strokeColor("#4472C4").lineWidth(2)
       .moveTo(60, doc.y).lineTo(552, doc.y).stroke();

    doc.moveDown(1);

    // Sections
    for (const section of sections) {
      if (doc.y > 680) doc.addPage();

      if (section.heading) {
        doc.fontSize(16).font("Helvetica-Bold").fillColor("#1a1a2e")
           .text(section.heading);
        doc.moveDown(0.3);
        doc.strokeColor("#4472C4").lineWidth(1)
           .moveTo(60, doc.y).lineTo(300, doc.y).stroke();
        doc.moveDown(0.5);
      }

      if (section.body) {
        doc.fontSize(11).font("Helvetica").fillColor("#333333")
           .text(section.body, { lineGap: 4 });
        doc.moveDown(0.8);
      }

      if (section.bullets) {
        for (const bullet of section.bullets) {
          if (doc.y > 700) doc.addPage();
          doc.fontSize(11).font("Helvetica").fillColor("#333333")
             .text(`  \u2022  ${bullet}`, { indent: 15, lineGap: 3 });
        }
        doc.moveDown(0.8);
      }

      if (section.table) {
        drawTable(doc, section.table);
        doc.moveDown(0.8);
      }
    }

    // Footer on each page
    const pages = doc.bufferedPageRange();
    for (let i = 0; i < pages.count; i++) {
      doc.switchToPage(i);
      doc.fontSize(8).fillColor("#aaaaaa")
         .text(`BACKBONE Engine | Page ${i + 1}`, 60, 740, { align: "center", width: 492 });
    }

    doc.end();

    stream.on("finish", () => resolve({ path: filePath, pages: pages.count }));
    stream.on("error", reject);
  });
}

/**
 * Draw a simple table in the PDF.
 */
function drawTable(doc, { headers, rows }) {
  const startX = 65;
  const colWidth = Math.min(120, (490 / headers.length));
  const rowHeight = 22;

  // Header
  let y = doc.y;
  doc.fontSize(9).font("Helvetica-Bold").fillColor("#FFFFFF");

  for (let i = 0; i < headers.length; i++) {
    doc.rect(startX + i * colWidth, y, colWidth, rowHeight).fill("#4472C4");
    doc.fillColor("#FFFFFF")
       .text(headers[i], startX + i * colWidth + 4, y + 6, { width: colWidth - 8, align: "left" });
  }

  y += rowHeight;

  // Data rows
  doc.font("Helvetica").fillColor("#333333");
  for (let r = 0; r < rows.length; r++) {
    if (y > 700) { doc.addPage(); y = 60; }

    const bgColor = r % 2 === 0 ? "#F2F2F2" : "#FFFFFF";

    for (let i = 0; i < headers.length; i++) {
      doc.rect(startX + i * colWidth, y, colWidth, rowHeight).fill(bgColor);
      doc.fillColor("#333333").fontSize(9)
         .text(String(rows[r]?.[i] ?? ""), startX + i * colWidth + 4, y + 6, { width: colWidth - 8, align: "left" });
    }
    y += rowHeight;
  }

  doc.y = y + 5;
}

/**
 * Create a research brief (shorter format, 1-2 pages).
 */
export async function createBrief(filename, { title, date, summary, keyFindings = [], recommendations = [], data = null }) {
  return createReport(filename, {
    title,
    subtitle: date || new Date().toLocaleDateString(),
    sections: [
      { heading: "Executive Summary", body: summary },
      keyFindings.length ? { heading: "Key Findings", bullets: keyFindings } : null,
      data ? { heading: "Data", table: data } : null,
      recommendations.length ? { heading: "Recommendations", bullets: recommendations } : null
    ].filter(Boolean)
  });
}

export function listDocuments() {
  ensureDir(DOCS_DIR);
  return fs.readdirSync(DOCS_DIR)
    .filter(f => f.endsWith(".pdf"))
    .map(f => {
      const fp = path.join(DOCS_DIR, f);
      const stats = fs.statSync(fp);
      return { name: f, path: fp, size: stats.size, modified: stats.mtime.toISOString() };
    });
}

export default { createReport, createBrief, listDocuments, resolveDocPath, DOCS_DIR };
